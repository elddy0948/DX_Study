# Function Template

## 함수 템플릿

함수의 **기능**은 결정되어 있지만, 자료형은 결정되지 않은 함수를 말합니다.

```cpp
template <typename T>
T Sum(T lhs, T rhs)
{
  return lhs + rhs;
}
```

### 템플릿 함수

이 **템플릿 함수**는 함수 템플릿에 의해 만들어지는 함수입니다. 즉, 함수 템플릿에서 자료형이 정해진 함수라고 할 수 있습니다.
만약 한번 만들어졌다면, 다음에 똑같은 자료형으로 함수를 호출할때에는 다시 만들지 않고, 만들어 둔 함수를 호출하게 됩니다.

**함수 템플릿** -> **템플릿 함수** 과정은 컴파일 시간에 진행이되는데, 이는 '컴파일 시간'을 느리게 하는 것이지, '실행 시간'을 느리게 하는 것은 아닙니다.

### 함수 템플릿의 특수화 (Specialization)

상황에 따라서 템플릿 함수의 '구현'이 달라져야할 때가 있습니다.
예를들어

```cpp
template <typename T>
T Max(T lhs, T rhs)
{
  return lhs > rhs ? lhs : rhs;
}
```

이런 템플릿 함수가 있다고 가정하겠습니다. 이는 정수나 실수를 비교하여 큰 값을 가져오는 방식에는 잘 동작하지만, **문자열과 같은 자료형에게는 잘 맞지 않는 구조를 가지고 있습니다.** 즉, 문자열의 크기를 비교하고싶을때는 의미가 없어지게 되는것입니다.

이때 사용하는것이 Specialization 입니다.

```cpp
template<>
const char* (const char* lhs, const char* rhs)
{
  return strlen(lhs) > strlen(rhs) ? lhs : rhs;
}
```

이런식으로 사용하게 된다면, 컴파일러는 `const char*` 타입에 대해서는 함수 템플릿을 보고 새로 생성하지 않고, 이미 정의된 위의 코드로 사용하게 되는것입니다.
즉, 개발자가 "const char* 타입은 새로 만들지 말고, 이거 써라!" 라고 컴파일러에게 알려주는것입니다.
